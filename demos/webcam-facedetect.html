<!doctype html>
<html>
<head>
<script src="lbpcascade_frontalface.js"></script>
<script src="../webcv.js"></script>
<script src="../webcv-utils.js"></script>
<script src="../webcv-shadersource.js"></script>
<script src="../webcv-shaders.js"></script>
<script src="../webcv-imgproc.js"></script>
<script src="../webcv-gpu.js"></script>
<script src="../webcv-facedetect.js"></script>
<script src="jquery.js"></script>
<script src="dat.gui.min.js"></script>

<!-- We use grouping function from objdetect or jsfeat library -->
<script src="objectdetect.js"></script>
<script>var jsfeat = {};</script>
<script src="jsfeat_haar.js"></script>
<script>

window.stop = false;
window.groupRects = false;
window.showBest = false;
window.minNeighbours = 4;
window.jsfeatGroup = false;

(function () {

    var vid;
    var fd;
    var drawShader;
    var rectShader;
    var vidTexture;
    var canvas;
    var attrs;
    var rectBuf;

    function rectangleVertices(rects) {
        var outArray = [];
        // Not optimised for speed
        for (var i=0; i<rects.length; i+=1) {
            // rect elements = [x,y,w,h]
            var rect = rects[i];
            // Correct for y inversion
            var x=rect[0],
                y=canvas.height - rect[1],
                w=rect[2],
                h=-rect[3];
            // Top left
            outArray.push(x);
            outArray.push(y);
            // Top right
            outArray.push(x + w);
            outArray.push(y);
            outArray.push(x + w);
            outArray.push(y);
            // Bottom right
            outArray.push(x + w);
            outArray.push(y + h);
            outArray.push(x + w);
            outArray.push(y + h);
            // Bottom left
            outArray.push(x);
            outArray.push(y + h);
            outArray.push(x);
            outArray.push(y + h);
            // Top left
            outArray.push(x);
            outArray.push(y);
        }
        return outArray;
    }

    function frameLoop() {
        var frameLoopStart = new Date();
        // Do detection
        var rects = fd.detect(vid);

        if (window.groupRects) {
            var groupStart = performance.now();
            if(jsfeatGroup) {
                rects = jsfeat.haar.group_rectangles(rects, window.minNeighbours);
            } else {
                rects = objectdetect.groupRectangles(rects, window.minNeighbours);
            }
            console.log("Group time", performance.now() - groupStart);
        }

        if(window.groupRects && window.showBest) {

            var bestNeighbourCount = 0;
            var bestRect;

            for (var i=0; i<rects.length; i+=1) {
                if (rects[i][4] > bestNeighbourCount) {
                    bestRect = rects[i];
                    bestNeighbourCount = rects[i][4];
                }
            }

            if(bestRect !== undefined) {
                rects = [bestRect];
            } else {
                rects = [];
            }

        }


        /*
        $('#webcamcontainer div').remove()

        $(rects).each(function(n,e) {
            var box = $('<div>');
                box.css({"border": "solid 1px red",
                    "position": "absolute",
                    "left": e[0],
                    "top": e[1],
                    "width": e[2],
                    "height": e[3]});
                $('#webcamcontainer').append(box);
            });
        */


        // Prepare to draw image
        gl.useProgram(drawShader);
        cv.shaders.setAttributes(drawShader, attrs);
        cv.gpu.uploadToTexture(vid, vidTexture);

        // XXX global pixelStorei set by uploadToTexture
        // messes up detection, reset here
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0)

        // Bind to texture unit 0
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, vidTexture);

        // Draw to screen
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, vid.width, vid.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        console.log("nfaces", rects.length);

        // Upload face rectangles to buffer
        var rectangleVerts = rectangleVertices(rects);
        gl.bindBuffer(gl.ARRAY_BUFFER, rectBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint16Array(rectangleVerts), gl.STATIC_DRAW);
        gl.useProgram(rectShader);
        cv.shaders.setAttributes(rectShader, {aPosition: rectBuf});
        gl.drawArrays(gl.LINES, 0, rectangleVerts.length/2);

        console.log("Frame loop time", new Date() - frameLoopStart);

        if (!stop) {
            cv.utils.requestAnimationFrame(frameLoop);
        }
    }

    function videoLoaded(stream) {
        fd = new FaceDetector(lbpcascade_frontalface, canvas.width, canvas.height);
        window.fd = fd;
        vid.src = stream;

        frameLoop();
    }

    $(document).ready(function () {
        canvas = document.getElementById("glcanvas");
        vid = document.getElementById("webcamvideo");

        window.cv = WebCV.create(canvas);
        if (cv.gl === null) {
            alert("WebGL not supported");
        }
        gl = cv.gl;
        window.gl = gl;

        vidTexture = cv.gpu.blankTexture(vid.width, vid.height);

        drawShader = cv.shaders.getNamedShader("draw2d");

        // A simple rectangle (2 triangles)
        var vertCoords = new Float32Array([
            0.0,   0.0,
            canvas.width, 0.0,
            0.0,   canvas.height,
            0.0,   canvas.height,
            canvas.width, 0.0,
            canvas.width, canvas.height]);

        var vertBuf = cv.shaders.arrayBuffer(vertCoords);

        // Set up the texture coordinates
        var texCoords = new Float32Array([
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            1.0, 1.0]);

        var texBuf = cv.shaders.arrayBuffer(texCoords);
        rectBuf = cv.shaders.arrayBuffer(new Uint16Array([0]));

        attrs = {
            aTextureCoord: texBuf,
            aPosition: vertBuf,
        };

        cv.shaders.setAttributes(drawShader, attrs);

        var uniforms = {
            "uResolution": [canvas.width, canvas.height],
            //"uImageSize": [400, 300]
        };

        cv.shaders.setUniforms(drawShader, uniforms);


        rectShader = cv.shaders.getNamedShader("drawconst");
        cv.shaders.setUniforms(rectShader, {uResolution: [canvas.width, canvas.height]});


        cv.utils.getUserMedia({video: true}, videoLoaded, function () { alert("Couldn't get webcam"); });

        // GUI
        var gui = new dat.GUI();
        gui.add(window, 'groupRects');
        gui.add(window, 'showBest');
        gui.add(window, 'minNeighbours', 0, 50);
        gui.add(window, 'stop').onChange(frameLoop);
        gui.add(window, 'jsfeatGroup');
    });

}());

</script>
</head>
<body>
<div id="webcamcontainer" style="position:relative">
    <video id="webcamvideo" autoplay width="320" height="240"></video>
</div>
<canvas id="glcanvas" width="320" height="240"></canvas>

</body>
</html>
